
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module minilab1b(

	//////////// CLOCK //////////
	input 		          		CLOCK_50,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW    // Using SW[3:0]
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

	// Synchronizers for SW[0] enable input
	logic enable_sync, enable_meta;
	logic enable_prev;
	logic start_pulse;
	logic rst_n_sync;

	// mat_vec_mult signals
	logic [7:0] b_in;
	logic [23:0] result [0:7];  // Unpacked array for results
	logic done, ready_for_b;

	// Memory interface signals
	logic [31:0] mem_address;
	logic mem_read;
	logic [63:0] mem_readdata;
	logic mem_readdatavalid;
	logic mem_waitrequest;

	// Display control
	logic [23:0] selected_result;

	// B vector feeding state machine
	logic [2:0] b_counter;
	logic [7:0] b_vector [0:7];  // Hardcoded B vector from test case
	logic feeding_b;

	// Initialize B vector (values from input_mem.mif address 8)
	assign b_vector[0] = 8'h81;
	assign b_vector[1] = 8'h82;
	assign b_vector[2] = 8'h83;
	assign b_vector[3] = 8'h84;
	assign b_vector[4] = 8'h85;
	assign b_vector[5] = 8'h86;
	assign b_vector[6] = 8'h87;
	assign b_vector[7] = 8'h88;

	// Seven segment decoder
	function [6:0] hex_to_7seg;
		input [3:0] hex;
		begin
			case(hex)
				4'h0: hex_to_7seg = 7'b1000000;
				4'h1: hex_to_7seg = 7'b1111001;
				4'h2: hex_to_7seg = 7'b0100100;
				4'h3: hex_to_7seg = 7'b0110000;
				4'h4: hex_to_7seg = 7'b0011001;
				4'h5: hex_to_7seg = 7'b0010010;
				4'h6: hex_to_7seg = 7'b0000010;
				4'h7: hex_to_7seg = 7'b1111000;
				4'h8: hex_to_7seg = 7'b0000000;
				4'h9: hex_to_7seg = 7'b0010000;
				4'hA: hex_to_7seg = 7'b0001000;
				4'hB: hex_to_7seg = 7'b0000011;
				4'hC: hex_to_7seg = 7'b1000110;
				4'hD: hex_to_7seg = 7'b0100001;
				4'hE: hex_to_7seg = 7'b0000110;
				4'hF: hex_to_7seg = 7'b0001110;
			endcase
		end
	endfunction

//=======================================================
//  Structural coding
//=======================================================

	// Reset logic: SW[0] is active-low reset (0=Reset, 1=Run)
	// We synchronize it to the clock domain
	always_ff @(posedge CLOCK_50) begin
		rst_n_sync <= SW[0];
	end

	// Start signal: In this simplified system, we can tie start to '1' so it runs
	// as soon as reset is released (IDLE -> Start)
	// Or we can say Start triggers once after Reset goes high.
	// Let's make it auto-start after reset.
	// Start signal: Directly tied to Reset/Enable signal
	// When SW[0] is High (Run), start is High.
	// The state machine waits for start=1. If it stays 1, it will just start immediately.
	// This matches the simple control style of Minilab 0.
	logic start_signal;
	assign start_signal = rst_n_sync;
	assign start_pulse = start_signal; // Re-use wire name for LED mapping if needed, or rename
	
	// Note: We use 'start_signal' to drive the module below.

	// Result Capture Logic
	// Since the machine auto-restarts and clears results in IDLE, we must capture
	// the valid results when 'done' is high to display them stably.
	logic [23:0] captured_result [0:7];
	always_ff @(posedge CLOCK_50 or negedge rst_n_sync) begin
		if (!rst_n_sync) begin
			for (int i=0; i<8; i++) captured_result[i] <= 24'b0;
		end else begin
			if (done) begin
				captured_result <= result;
			end
		end
	end

	// Select which result to display (use SW[3:1] to select result 0-7)
	// Use the CAPTURED result so it doesn't flicker to 0.
	always_comb begin
		selected_result = captured_result[SW[3:1]];
	end

	// B vector feeding logic
	// Feed automatically when ready_for_b is active
	always_ff @(posedge CLOCK_50 or negedge rst_n_sync) begin
		if (!rst_n_sync) begin
			b_counter <= 3'b0;
			feeding_b <= 1'b0;
			b_in <= 8'h00;
		end else begin
			if (ready_for_b) begin
				if (!feeding_b) begin
					// Start feeding
					feeding_b <= 1'b1;
					b_counter <= 3'b0;
					b_in <= b_vector[0]; // Feed first element
				end else begin
					// Continue feeding
					b_in <= b_vector[b_counter + 1]; // Look ahead since B propagates
					b_counter <= b_counter + 1'b1;
				end
			end else begin
				feeding_b <= 1'b0;
                b_counter <= 3'b0;
			end
		end
	end

	// Display selected result on HEX displays (6 hex digits for 24-bit result)
	assign HEX0 = hex_to_7seg(selected_result[3:0]);
	assign HEX1 = hex_to_7seg(selected_result[7:4]);
	assign HEX2 = hex_to_7seg(selected_result[11:8]);
	assign HEX3 = hex_to_7seg(selected_result[15:12]);
	assign HEX4 = hex_to_7seg(selected_result[19:16]);
	assign HEX5 = hex_to_7seg(selected_result[23:20]);

	// Status LEDs
	// LEDR[0]: Done
	// LEDR[1]: Ready for B
	// LEDR[4:2]: State (we need to expose this from the module if we want to see it, 
	//            but for now we can just leave them 0 or map other debug signals)
	assign LEDR[0] = done;
	assign LEDR[1] = ready_for_b;
	assign LEDR[2] = feeding_b;
	assign LEDR[3] = start_pulse;
	assign LEDR[4] = rst_n_sync;
	assign LEDR[5] = mem_waitrequest;
	assign LEDR[6] = mem_readdatavalid;
	assign LEDR[7] = mem_read;
	assign LEDR[9:8] = 2'b0;

	// Instantiate memory wrapper (provides matrix A data)
	mem_wrapper mem_inst (
		.clk(CLOCK_50),
		.reset_n(rst_n_sync),
		.address(mem_address),
		.read(mem_read),
		.readdata(mem_readdata),
		.readdatavalid(mem_readdatavalid),
		.waitrequest(mem_waitrequest)
	);

	// Instantiate matrix-vector multiplication module
	mat_vec_mult #(
		.DATA_WIDTH(8),
		.FIFO_DEPTH(8),
		.NUM_MACS(8)
	) mat_vec_mult_inst (
		.clk(CLOCK_50),
		.rst_n(rst_n_sync),
		.start(start_signal),
		.b_in(b_in),
		.result(result),
		.done(done),
		.ready_for_b(ready_for_b),
		// Memory interface
		.mem_address(mem_address),
		.mem_read(mem_read),
		.mem_readdata(mem_readdata),
		.mem_readdatavalid(mem_readdatavalid),
		.mem_waitrequest(mem_waitrequest)
	);

endmodule
